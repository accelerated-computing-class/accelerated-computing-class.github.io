<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><title>6.S894</title><base href="/fall24/labs/lab7/"><meta content="width=device-width, initial-scale=1" name="viewport"><style>@font-face {
    font-family: "Tex Gyre Heros";
    src: url("/fall24/assets/font/tex-gyre-heros/texgyreheros-regular.otf") format("opentype");
    font-weight: regular;
    font-style: regular;
}
@font-face {
    font-family: "Tex Gyre Heros";
    src: url("/fall24/assets/font/tex-gyre-heros/texgyreheros-bold.otf") format("opentype");
    font-weight: bold;
    font-style: regular;
}
@font-face {
    font-family: "Tex Gyre Heros";
    src: url("/fall24/assets/font/tex-gyre-heros/texgyreheros-italic.otf") format("opentype");
    font-weight: regular;
    font-style: italic;
}
@font-face {
    font-family: "Tex Gyre Heros";
    src: url("/fall24/assets/font/tex-gyre-heros/texgyreheros-bolditalic.otf") format("opentype");
    font-weight: bold;
    font-style: italic;
}</style><link href="/fall24/assets/main.css" rel="stylesheet"><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" rel="stylesheet"><link href="/fall24/assets/favicon.png" rel="icon" type="image/png"></head><body><header><nav><h1><a href="/fall24/">6.S894</a></h1>
<p><a href="/fall24/calendar">Calendar</a></p>
<p><a href="/fall24/labs">Labs</a></p>
<p><a href="/fall24/syllabus">Syllabus</a></p>
<p><a href="/fall24/resources">Resources</a></p>
<p><a href="/fall24/contact">Contact</a></p>
<p><a href="/fall24/piazza">Piazza</a></p>
</nav></header><main><h1>Lab 7: Run-Length Compression</h1>
<h2>Prologue: Logistics</h2>
<h3>Due Dates</h3>
<p>For this lab, you’ll be turning in the following deliverables:</p>
<ul>
<li>
<p><strong>Checkpoint:</strong> Due Monday, October 28, 11:59pm (<a href="https://www.gradescope.com/courses/849967/assignments/5224123/">Gradescope</a>)</p>
</li>
<li>
<p><strong>Final Submission:</strong> Due Friday, November 1, 11:59pm</p>
</li>
</ul>
<p>See the “Deliverables” section at the end of this document for more information on what you’ll be turning in.</p>
<h3>Starter Code</h3>
<p>You can get the starter code for this lab by cloning the <a href="https://github.com/accelerated-computing-class/lab7">lab repository</a>:</p>
<pre><span class="highlight-source highlight-shell highlight-bash"><span class="highlight-meta highlight-function-call highlight-shell"><span class="highlight-variable highlight-function highlight-shell">git</span></span><span class="highlight-meta highlight-function-call highlight-arguments highlight-shell"> clone git@github.com:accelerated-computing-class/lab7.git</span>
</span></pre>
<blockquote>
<p><strong>Update October 28:</strong> The starter code has been updated since its initial release, and now includes the files <a href="https://github.com/accelerated-computing-class/lab7/blob/main/rle_compress.cu"><code>rle_compress.cu</code></a> and <a href="https://github.com/accelerated-computing-class/lab7/blob/main/rle_decompress.cu"><code>rle_decompress.cu</code></a>. If you cloned the repo before this update, please pull the latest commit, or manually copy the new files to your computer:</p>
<ul>
<li><a href="https://raw.githubusercontent.com/accelerated-computing-class/lab7/refs/heads/main/rle_compress.cu">Link to raw <code>rle_compress.cu</code></a></li>
<li><a href="https://raw.githubusercontent.com/accelerated-computing-class/lab7/refs/heads/main/rle_decompress.cu">Link to raw <code>rle_decompress.cu</code></a></li>
</ul>
</blockquote>
<h2>Introduction</h2>
<h3>Goals for This Lab</h3>
<p>So far in this course, we’ve only looked at workloads with so-called “<strong>regular</strong>” data access patterns, in which data dependencies were predictable and consistent across different parts of the computation:</p>
<ul>
<li>
<p>In Mandelbrot (<a href="/fall24/labs/lab1">Lab 1</a>, <a href="/fall24/labs/lab2">2</a>), each pixel lived at a fixed position in the image, which was known before we started computing that pixel’s value.</p>
</li>
<li>
<p>In our wave simulation (<a href="/fall24/labs/lab3">Lab 3</a>), every grid cell lived at a fixed position in the <code>u</code> array, and updating each cell only required looking at its immediate neighbors in a fixed pattern.</p>
</li>
<li>
<p>In matrix multiply (<a href="/fall24/labs/lab4">Lab 4</a>, <a href="/fall24/labs/lab5">5</a>, <a href="/fall24/labs/lab6">6</a>), every element of the <em>C</em> matrix depended only on a fixed set of indices in the <em>A</em> and <em>B</em> matrices, and there was a fixed pattern determining which elements of <em>A</em> were to be multiplied with which elements of <em>B</em>.</p>
</li>
</ul>
<p>In this lab, we’ll start looking at how GPUs can be used to carry out computations requiring <strong>irregular</strong> memory access patterns, where the locations accessed by different parts of the computation depend on details of the input data which can only be determined dynamically.</p>
<p>Ultimately, our goal in this lab will be to develop a fast GPU implementation of <a href="https://en.wikipedia.org/wiki/Run-length_encoding"><strong>run-length compression</strong></a>. As we’ll see, the memory access patterns required to carry out run-length compression are interestingly irregular, because the length of each run cannot be known before looking at the data. To help us write our run-length compression algorithm, we’ll be implementing a useful generic algorithm known as a <a href="https://en.wikipedia.org/wiki/Prefix_sum">“scan”</a> (also called “prefix sum” or “cumulative sum”).</p>
<p>This lab is split into two <strong>main</strong> parts, and a third <strong>optional</strong> part:</p>
<ol>
<li>
<p>In Part 1, we’ll implement a <strong>scan</strong> algorithm for the GPU. The scan algorithm itself is <strong>regular</strong>; however, as we’ll see, scan provides a very useful building block for implementing other, irregular algorithms.</p>
</li>
<li>
<p>In Part 2, we’ll implement <strong>run-length compression</strong> on the GPU. To do this, we’ll make use of the scan we developed in Part 1.</p>
</li>
<li>
<p>Part 3 is <strong>optional</strong>, and invites you to try implementing a fast <strong>decompression</strong> algorithm for the run-length encoding scheme from Part 2. This part will be worth <strong>extra credit</strong>, and we encourage you to try it if you have time!</p>
</li>
</ol>
<h2>Part 1: Associative Scan</h2>
<h3>Introduction</h3>
<p>For the first part of this lab, we’ll be implementing an “<strong>associative scan</strong>” on the GPU. An associative scan can be described by the following sequential pseudocode:</p>
<pre><span class="highlight-source highlight-python"><span class="highlight-meta highlight-function highlight-python"><span class="highlight-storage highlight-type highlight-function highlight-python">def</span> <span class="highlight-entity highlight-name highlight-function highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">scan</span></span></span><span class="highlight-meta highlight-function highlight-parameters highlight-python"><span class="highlight-punctuation highlight-section highlight-parameters highlight-begin highlight-python">(</span></span><span class="highlight-meta highlight-function highlight-parameters highlight-python"><span class="highlight-variable highlight-parameter highlight-python">x</span><span class="highlight-punctuation highlight-separator highlight-parameters highlight-python">,</span> <span class="highlight-variable highlight-parameter highlight-python">out</span><span class="highlight-punctuation highlight-section highlight-parameters highlight-end highlight-python">)</span></span><span class="highlight-meta highlight-function highlight-python"><span class="highlight-punctuation highlight-section highlight-function highlight-begin highlight-python">:</span></span>
    <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">accumulator</span></span> <span class="highlight-keyword highlight-operator highlight-assignment highlight-python">=</span> <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">identity</span></span>
    <span class="highlight-meta highlight-statement highlight-for highlight-python"><span class="highlight-keyword highlight-control highlight-flow highlight-for highlight-python">for</span> <span class="highlight-meta highlight-generic-name highlight-python">i</span> <span class="highlight-meta highlight-statement highlight-for highlight-python"><span class="highlight-keyword highlight-control highlight-flow highlight-for highlight-in highlight-python">in</span></span></span><span class="highlight-meta highlight-statement highlight-for highlight-python"> <span class="highlight-meta highlight-function-call highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-support highlight-function highlight-builtin highlight-python">range</span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-begin highlight-python">(</span><span class="highlight-meta highlight-function-call highlight-arguments highlight-python"><span class="highlight-meta highlight-function-call highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-support highlight-function highlight-builtin highlight-python">len</span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-begin highlight-python">(</span><span class="highlight-meta highlight-function-call highlight-arguments highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">x</span></span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-end highlight-python">)</span></span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-end highlight-python">)</span></span><span class="highlight-punctuation highlight-section highlight-block highlight-for highlight-python">:</span></span>
        <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">accumulator</span></span> <span class="highlight-keyword highlight-operator highlight-assignment highlight-python">=</span> <span class="highlight-meta highlight-function-call highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-variable highlight-function highlight-python">combine</span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-begin highlight-python">(</span><span class="highlight-meta highlight-function-call highlight-arguments highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">accumulator</span></span><span class="highlight-punctuation highlight-separator highlight-arguments highlight-python">,</span> <span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">x</span></span></span><span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-punctuation highlight-section highlight-brackets highlight-begin highlight-python">[</span></span><span class="highlight-meta highlight-item-access highlight-arguments highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">i</span></span></span><span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-punctuation highlight-section highlight-brackets highlight-end highlight-python">]</span></span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-end highlight-python">)</span></span>
        <span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">out</span></span></span><span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-punctuation highlight-section highlight-brackets highlight-begin highlight-python">[</span></span><span class="highlight-meta highlight-item-access highlight-arguments highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">i</span></span></span><span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-punctuation highlight-section highlight-brackets highlight-end highlight-python">]</span></span> <span class="highlight-keyword highlight-operator highlight-assignment highlight-python">=</span> <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">accumulator</span></span>
</span></pre>
<p>where <code>combine</code> is some <a href="https://en.wikipedia.org/wiki/Associative_property">associative</a> (but not necessarily <a href="https://en.wikipedia.org/wiki/Commutative_property">commutative</a>) function of two arguments, and <code>identity</code> is the <a href="https://en.wikipedia.org/wiki/Identity_(mathematics)">identity</a> element with respect to that operation.<sup class="footnote-reference"><a href="#monoid">1</a></sup> The elements of <code>x</code> can be of any data type, as long as they’re compatible with the <code>combine</code> operation. In practice, it’s common for <code>combine</code> to be <code>+</code>, and for <code>identity</code> to be <code>0</code>, but other operations can be useful as well. For example, <code>combine</code> may be <code>max</code>, in which case <code>identity</code> would be <code>-∞</code>.</p>
<p>We can depict a scan diagrammatically as follows:</p>
<p><img src="images/scan-intro.svg" alt="" /></p>
<p>Throughout this lab, we’ll adopt a notation in which “<code>i : j</code>” stands for the combination of all elements with indices between between <code>i</code> (inclusive) and <code>j</code> (exclusive). We’ll call such a combination of elements a “partial reduction.” Using this notation, we can think of each input element in <code>x</code> as a partial reduction of a range containing just one element; i.e., the element <code>x[i]</code> can be written as the partial reduction <code>i:i+1</code>. In this notation, the goal of the associative scan is just to fill each element <code>i</code> of the output array with the partial reduction from <code>0</code> to <code>i+1</code>:</p>
<pre><span class="highlight-source highlight-python"><span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">out</span></span></span><span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-punctuation highlight-section highlight-brackets highlight-begin highlight-python">[</span></span><span class="highlight-meta highlight-item-access highlight-arguments highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">i</span></span></span><span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-punctuation highlight-section highlight-brackets highlight-end highlight-python">]</span></span> <span class="highlight-keyword highlight-operator highlight-assignment highlight-python">=</span> <span class="highlight-constant highlight-numeric highlight-integer highlight-decimal highlight-python">0</span><span class="highlight-punctuation highlight-separator highlight-annotation highlight-variable highlight-python">:</span><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">i</span></span><span class="highlight-keyword highlight-operator highlight-arithmetic highlight-python">+</span><span class="highlight-constant highlight-numeric highlight-integer highlight-decimal highlight-python">1</span>
</span></pre>
<p>The main thing we can do with partial reductions is combine them. Given partial reductions <code>i:j</code> and <code>j:k</code>, we can compute <code>i:k = combine(i:j, j:k)</code>. Note that in order to (usefully) combine two partial reductions <code>i:j</code> and <code>j:k</code>, they need to share a common endpoint <code>j</code>. If you try to combine partial reductions <code>i:j</code> and <code>l:k</code> with <code>j != l</code>, then the resulting value won’t correspond to any contiguous subsequence of the input array, and won’t be very useful for the associative scan. (In the general case where <code>combine</code> is not commutative, there’s no way to “fill in the hole” in such a non-contiguous partial reduction after you’ve computed it.)</p>
<h4>Understanding the Starter Code</h4>
<p>You can find the starter code for Part 1 in the file <code>scan.cu</code>. In this file, we’ll be writing our associative scan as a <strong>C++ template</strong> to allow plugging in multiple different operations in place of <code>combine</code> without needing to rewrite our code. In the starter code, we give an example of a naive sequential scan on the CPU expressed as such a C++ template:</p>
<pre><span class="highlight-source highlight-c++"><span class="highlight-meta highlight-template highlight-c++"><span class="highlight-storage highlight-type highlight-template highlight-c++">template</span> <span class="highlight-punctuation highlight-section highlight-generic highlight-begin highlight-c++">&lt;</span></span><span class="highlight-meta highlight-template highlight-c++"><span class="highlight-storage highlight-type highlight-c++">typename</span> Op</span><span class="highlight-meta highlight-template highlight-c++"><span class="highlight-punctuation highlight-section highlight-generic highlight-end highlight-c++">&gt;</span></span>
<span class="highlight-storage highlight-type highlight-c">void</span> <span class="highlight-meta highlight-function highlight-c++"><span class="highlight-entity highlight-name highlight-function highlight-c++">scan_cpu</span></span><span class="highlight-meta highlight-function highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span></span></span><span class="highlight-meta highlight-function highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-support highlight-type highlight-sys-types highlight-c">size_t</span> <span class="highlight-variable highlight-parameter highlight-c++">n</span><span class="highlight-punctuation highlight-separator highlight-c++">,</span> <span class="highlight-storage highlight-modifier highlight-c++">typename</span> Op<span class="highlight-punctuation highlight-accessor highlight-c++">::</span>Data <span class="highlight-storage highlight-modifier highlight-c++">const</span> <span class="highlight-keyword highlight-operator highlight-c">*</span><span class="highlight-variable highlight-parameter highlight-c++">x</span><span class="highlight-punctuation highlight-separator highlight-c++">,</span> <span class="highlight-storage highlight-modifier highlight-c++">typename</span> Op<span class="highlight-punctuation highlight-accessor highlight-c++">::</span>Data <span class="highlight-keyword highlight-operator highlight-c">*</span><span class="highlight-variable highlight-parameter highlight-c++">out</span><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span></span><span class="highlight-meta highlight-function highlight-c++"> </span><span class="highlight-meta highlight-function highlight-c++"><span class="highlight-meta highlight-block highlight-c++"><span class="highlight-punctuation highlight-section highlight-block highlight-begin highlight-c++">{</span></span></span><span class="highlight-meta highlight-function highlight-c++"><span class="highlight-meta highlight-block highlight-c++">
    <span class="highlight-keyword highlight-control highlight-c++">using</span> Data <span class="highlight-keyword highlight-operator highlight-assignment highlight-c">=</span> <span class="highlight-storage highlight-modifier highlight-c++">typename</span> Op<span class="highlight-punctuation highlight-accessor highlight-c++">::</span>Data<span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
    Data accumulator <span class="highlight-keyword highlight-operator highlight-assignment highlight-c">=</span> <span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-variable highlight-function highlight-c++">Op<span class="highlight-punctuation highlight-accessor highlight-c++">::</span></span><span class="highlight-variable highlight-function highlight-c++">identity</span><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span></span></span><span class="highlight-meta highlight-function-call highlight-c++"></span><span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
    <span class="highlight-keyword highlight-control highlight-c++">for</span> <span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span><span class="highlight-support highlight-type highlight-sys-types highlight-c">size_t</span> i <span class="highlight-keyword highlight-operator highlight-assignment highlight-c">=</span> <span class="highlight-constant highlight-numeric highlight-c++">0</span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span> i <span class="highlight-keyword highlight-operator highlight-comparison highlight-c">&lt;</span> n<span class="highlight-punctuation highlight-terminator highlight-c++">;</span> i<span class="highlight-keyword highlight-operator highlight-arithmetic highlight-c">+</span><span class="highlight-keyword highlight-operator highlight-arithmetic highlight-c">+</span><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span> <span class="highlight-meta highlight-block highlight-c++"><span class="highlight-punctuation highlight-section highlight-block highlight-begin highlight-c++">{</span>
        accumulator <span class="highlight-keyword highlight-operator highlight-assignment highlight-c">=</span> <span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-variable highlight-function highlight-c++">Op<span class="highlight-punctuation highlight-accessor highlight-c++">::</span></span><span class="highlight-variable highlight-function highlight-c++">combine</span><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span></span></span><span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-meta highlight-group highlight-c++">accumulator<span class="highlight-punctuation highlight-separator highlight-c++">,</span> x<span class="highlight-meta highlight-brackets highlight-c++"><span class="highlight-punctuation highlight-section highlight-brackets highlight-begin highlight-c++">[</span>i<span class="highlight-punctuation highlight-section highlight-brackets highlight-end highlight-c++">]</span></span></span></span><span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
        out<span class="highlight-meta highlight-brackets highlight-c++"><span class="highlight-punctuation highlight-section highlight-brackets highlight-begin highlight-c++">[</span>i<span class="highlight-punctuation highlight-section highlight-brackets highlight-end highlight-c++">]</span></span> <span class="highlight-keyword highlight-operator highlight-assignment highlight-c">=</span> accumulator<span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
    <span class="highlight-punctuation highlight-section highlight-block highlight-end highlight-c++">}</span></span>
</span></span><span class="highlight-meta highlight-function highlight-c++"><span class="highlight-meta highlight-block highlight-c++"><span class="highlight-punctuation highlight-section highlight-block highlight-end highlight-c++">}</span></span></span>
</span></pre>
<p>Here <code>Op</code> is a type parameter representing the operation we’ll be using for the scan. The <code>Op</code> type is guaranteed to expose the following API:</p>
<pre><span class="highlight-source highlight-c++"><span class="highlight-meta highlight-struct highlight-c++"><span class="highlight-storage highlight-type highlight-c++">struct</span> <span class="highlight-entity highlight-name highlight-struct highlight-c++">ExampleOp</span></span><span class="highlight-meta highlight-struct highlight-c++"> <span class="highlight-meta highlight-block highlight-c++"><span class="highlight-punctuation highlight-section highlight-block highlight-begin highlight-c++">{</span></span></span><span class="highlight-meta highlight-struct highlight-c++"><span class="highlight-meta highlight-block highlight-c++">
    <span class="highlight-keyword highlight-control highlight-c++">using</span> Data <span class="highlight-keyword highlight-operator highlight-assignment highlight-c">=</span> <span class="highlight-comment highlight-block highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">/*</span> some type, e.g. uint32_t ... <span class="highlight-punctuation highlight-definition highlight-comment highlight-c">*/</span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>

    <span class="highlight-comment highlight-line highlight-double-slash highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">//</span> Combine two values of type &#39;Data&#39;
</span>    <span class="highlight-storage highlight-modifier highlight-c++">static</span> Data <span class="highlight-meta highlight-method highlight-c++"><span class="highlight-entity highlight-name highlight-function highlight-c++">combine</span></span><span class="highlight-meta highlight-method highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span></span></span><span class="highlight-meta highlight-method highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++">Data <span class="highlight-variable highlight-parameter highlight-c++">a</span><span class="highlight-punctuation highlight-separator highlight-c++">,</span> Data <span class="highlight-variable highlight-parameter highlight-c++">b</span><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span></span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>

    <span class="highlight-comment highlight-line highlight-double-slash highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">//</span> Get the identity element for &#39;combine&#39;
</span>    <span class="highlight-storage highlight-modifier highlight-c++">static</span> Data <span class="highlight-meta highlight-method highlight-c++"><span class="highlight-entity highlight-name highlight-function highlight-c++">identity</span></span><span class="highlight-meta highlight-method highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span></span></span><span class="highlight-meta highlight-method highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span></span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
</span></span><span class="highlight-meta highlight-struct highlight-c++"><span class="highlight-meta highlight-block highlight-c++"><span class="highlight-punctuation highlight-section highlight-block highlight-end highlight-c++">}</span></span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
</span></pre>
<p>You may assume that the functions <code>combine</code> and <code>identity</code> can be safely and efficiently called from <strong>both</strong> the CPU and GPU.</p>
<p>Note that due to a <a href="https://stackoverflow.com/a/613132">regrettable quirk</a> of C++ syntax, you can’t refer to the <code>Op::Data</code> type directly as “<code>Op::Data</code>”. Instead, you need to either write it as “<code>typename Op::Data</code>” as in:</p>
<pre><span class="highlight-source highlight-c++"><span class="highlight-storage highlight-modifier highlight-c++">typename</span> Op<span class="highlight-punctuation highlight-accessor highlight-c++">::</span>Data accumulator <span class="highlight-keyword highlight-operator highlight-assignment highlight-c">=</span> <span class="highlight-comment highlight-block highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">/*</span> ... <span class="highlight-punctuation highlight-definition highlight-comment highlight-c">*/</span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
</span></pre>
<p>or else bind it to a shorter name with the <code>using</code> keyword:</p>
<pre><span class="highlight-source highlight-c++"><span class="highlight-keyword highlight-control highlight-c++">using</span> Data <span class="highlight-keyword highlight-operator highlight-assignment highlight-c">=</span> <span class="highlight-storage highlight-modifier highlight-c++">typename</span> Op<span class="highlight-punctuation highlight-accessor highlight-c++">::</span>Data<span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
</span></pre>
<p>In the CPU scan example, we’re forced to use the <code>typename</code> syntax in the argument list of the function, but we’re able to use the “<code>using</code>” trick in the body. Similar considerations will probably apply in your own code.</p>
<p>In the test harness included with the starter code, your GPU scan implementation will be tested with two different operations:</p>
<ul>
<li>
<p><strong><code>SumOp</code></strong>, where <code>Data</code> is <code>uint32_t</code>, and <code>combine</code> is addition.</p>
</li>
<li>
<p><strong><code>DebugRangeConcatOp</code></strong>, where <code>Data</code> is a pair of integers representing a <strong>partial reduction range</strong>, and <code>combine</code> concatenates partial reduction ranges sharing a common endpoint (i.e., <code>combine(i:j, j:k) = i:k</code>).</p>
</li>
</ul>
<p>The purpose of <code>DebugRangeConcatOp</code> is to make debugging your code easier, by directly tracking which range of indices each partial reduction value comes from. Because <code>DebugRangeConcatOp</code> is only for debugging, the starter code will only benchmark the performance of your kernel using <code>SumOp</code>, not <code>DebugRangeConcatOp</code>.</p>
<p>As a final note, one feature of the starter code which you may find useful is the function <code>print_array</code>, which you can use to print the contents of an array of <code>Op::Data</code> values like this:</p>
<pre><span class="highlight-source highlight-c++">print_array<span class="highlight-punctuation highlight-section highlight-generic highlight-begin highlight-c++">&lt;</span>Op<span class="highlight-punctuation highlight-section highlight-generic highlight-end highlight-c++">&gt;</span><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span>array_length<span class="highlight-punctuation highlight-separator highlight-c++">,</span> array_ptr<span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
</span></pre>
<p>The <code>array_ptr</code> argument may point to a buffer on either the CPU or the GPU.</p>

<h3>Implementation</h3>
<p>The goal of Part 1 of this lab will be to write a fast associative scan implementation for the GPU:</p>
<blockquote>
<p><strong>Deliverable:</strong> In the file <code>scan.cu</code>, implement the function <code>launch_scan</code>, and any associated kernels, to perform an associative scan on the GPU. Aim to hit a throughput of <code>134 GB/s</code> or better, which is 30% of the theoretical peak bandwidth of our RTX A4000 GPU (<code>448 GB/s</code>).</p>
</blockquote>
<p>The “throughput” reported by the benchmark harness is based on the theoretical minimum amount of data movement required to implement the scan (one read and one write for each element), divided by the time taken to execute the scan:</p>
<pre><code>throughput = 2 * n * sizeof(Op::Data) / time
</code></pre>
<p>We’ll only evaluate the performance of your scan implementation on an array of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>26</mn></msup></mrow><annotation encoding="application/x-tex">2^{26}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">26</span></span></span></span></span></span></span></span></span></span></span></span> (roughly 67 million).</p>
<p>You won’t need to use any unfamiliar features of CUDA to implement this scan – it’s possible to write a fast implementation entirely using features we’ve already seen in this course. That said, we have some high-level suggestions to offer which you may find helpful.</p>
<h4>Suggestions</h4>
<p>There are a few fundamental patterns for producing and manipulating partial reduction values which you may find it helpful to keep in mind as you design your kernel.</p>
<p>One such pattern is to perform a collection of <strong>local scans</strong> in <strong>parallel</strong>, each computing a scan over a segment of the input sequence:</p>
<p><img src="images/scan-local.svg" alt="" /></p>
<p>After you’ve computed a collection of local scans, you can collect the partial reduction values from the <strong>endpoints</strong> of multiple local segments, and perform a scan over those endpoint values to compute reductions over larger intervals of the sequence. This gives rise to a <strong>hierarchical scan</strong>:</p>
<p><img src="images/scan-hierarchical.svg" alt="" /></p>
<p>Finally, given the results of a local scan over a segment, and a partial reduction value over <strong>preceding</strong> indices in the sequence, you can “<strong>fix up</strong>” the values in the local scan segment by combining them with the preceding partial reduction value:</p>
<p><img src="images/scan-fix-up.svg" alt="" /></p>
<p>How you use these patterns in your implementation – and, in fact, whether you use them at all – is up to you. Potentially, you can chain multiple instances of each pattern together across <strong>multiple levels of hierarchy</strong>. Some final questions you may want to consider include:</p>
<ul>
<li>
<p>How should you map your computation to the <strong>memory hierarchy</strong> of the GPU? Is there any way you can take advantage of <strong>L1 cache</strong> or <strong>shared memory</strong>?</p>
</li>
<li>
<p>How should you map your computation to the <strong>compute hierarchy</strong> of the GPU? What should each CUDA thread be responsible for? How about each block?</p>
</li>
<li>
<p>How many <strong>kernel launches</strong> should you use? Is there a way you can chain multiple kernels together to build your solution?</p>
</li>
<li>
<p>Do you need any extra <strong>scratch buffers</strong> in global memory to implement your solution? (If so, you should define the function <code>get_workspace_size</code> in the starter code!)</p>
</li>
</ul>
<h4>CUDA Quirk: Dynamic Shared Memory in Templates</h4>
<p>If you use <a href="https://developer.nvidia.com/blog/using-shared-memory-cuda-cc/">dynamic shared memory</a> in your solution, you may run into an arcane CUDA issue which we (the course staff) only became aware of while designing this assignment.</p>
<p>If you try to define a templated CUDA kernel which uses a dynamic shared memory allocation whose <strong>type depends on a template parameter</strong>, you’ll get compile errors if you try to instantiate the template multiple times with different types:</p>
<pre><span class="highlight-source highlight-c++"><span class="highlight-meta highlight-template highlight-c++"><span class="highlight-storage highlight-type highlight-template highlight-c++">template</span><span class="highlight-punctuation highlight-section highlight-generic highlight-begin highlight-c++">&lt;</span></span><span class="highlight-meta highlight-template highlight-c++"><span class="highlight-storage highlight-type highlight-c++">typename</span> T</span><span class="highlight-meta highlight-template highlight-c++"><span class="highlight-punctuation highlight-section highlight-generic highlight-end highlight-c++">&gt;</span></span>
__global__ <span class="highlight-storage highlight-type highlight-c">void</span> <span class="highlight-meta highlight-function highlight-c++"><span class="highlight-entity highlight-name highlight-function highlight-c++">example</span></span><span class="highlight-meta highlight-function highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span></span></span><span class="highlight-meta highlight-function highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span></span><span class="highlight-meta highlight-function highlight-c++"> </span><span class="highlight-meta highlight-function highlight-c++"><span class="highlight-meta highlight-block highlight-c++"><span class="highlight-punctuation highlight-section highlight-block highlight-begin highlight-c++">{</span></span></span><span class="highlight-meta highlight-function highlight-c++"><span class="highlight-meta highlight-block highlight-c++">
    <span class="highlight-storage highlight-modifier highlight-c++">extern</span> __shared__ T shmem<span class="highlight-meta highlight-brackets highlight-c++"><span class="highlight-punctuation highlight-section highlight-brackets highlight-begin highlight-c++">[</span><span class="highlight-punctuation highlight-section highlight-brackets highlight-end highlight-c++">]</span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span> <span class="highlight-comment highlight-line highlight-double-slash highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">//</span> error!
</span>    <span class="highlight-comment highlight-block highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">/*</span> ... <span class="highlight-punctuation highlight-definition highlight-comment highlight-c">*/</span></span>
</span></span><span class="highlight-meta highlight-function highlight-c++"><span class="highlight-meta highlight-block highlight-c++"><span class="highlight-punctuation highlight-section highlight-block highlight-end highlight-c++">}</span></span></span>

<span class="highlight-storage highlight-type highlight-c">int</span> <span class="highlight-meta highlight-function highlight-c++"><span class="highlight-entity highlight-name highlight-function highlight-c++">main</span></span><span class="highlight-meta highlight-function highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span></span></span><span class="highlight-meta highlight-function highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span></span><span class="highlight-meta highlight-function highlight-c++"> </span><span class="highlight-meta highlight-function highlight-c++"><span class="highlight-meta highlight-block highlight-c++"><span class="highlight-punctuation highlight-section highlight-block highlight-begin highlight-c++">{</span></span></span><span class="highlight-meta highlight-function highlight-c++"><span class="highlight-meta highlight-block highlight-c++">
    example<span class="highlight-punctuation highlight-section highlight-generic highlight-begin highlight-c++">&lt;</span><span class="highlight-support highlight-type highlight-stdint highlight-c">int32_t</span><span class="highlight-punctuation highlight-section highlight-generic highlight-end highlight-c++">&gt;</span><span class="highlight-keyword highlight-operator highlight-arithmetic highlight-c">&lt;&lt;</span><span class="highlight-keyword highlight-operator highlight-comparison highlight-c">&lt;</span><span class="highlight-constant highlight-numeric highlight-c++">1</span><span class="highlight-punctuation highlight-separator highlight-c++">,</span> <span class="highlight-constant highlight-numeric highlight-c++">1</span><span class="highlight-keyword highlight-operator highlight-arithmetic highlight-c">&gt;&gt;</span><span class="highlight-keyword highlight-operator highlight-comparison highlight-c">&gt;</span><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
    example<span class="highlight-punctuation highlight-section highlight-generic highlight-begin highlight-c++">&lt;</span><span class="highlight-storage highlight-type highlight-c">float</span><span class="highlight-punctuation highlight-section highlight-generic highlight-end highlight-c++">&gt;</span><span class="highlight-keyword highlight-operator highlight-arithmetic highlight-c">&lt;&lt;</span><span class="highlight-keyword highlight-operator highlight-comparison highlight-c">&lt;</span><span class="highlight-constant highlight-numeric highlight-c++">1</span><span class="highlight-punctuation highlight-separator highlight-c++">,</span> <span class="highlight-constant highlight-numeric highlight-c++">1</span><span class="highlight-keyword highlight-operator highlight-arithmetic highlight-c">&gt;&gt;</span><span class="highlight-keyword highlight-operator highlight-comparison highlight-c">&gt;</span><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
</span></span><span class="highlight-meta highlight-function highlight-c++"><span class="highlight-meta highlight-block highlight-c++"><span class="highlight-punctuation highlight-section highlight-block highlight-end highlight-c++">}</span></span></span>
</span></pre>
<p>(You can view this example on Compiler Explorer: <a href="https://godbolt.org/z/7erbP37bb">link</a>)</p>
<p>As discussed in this <a href="https://stackoverflow.com/a/27570775">Stack Overflow answer</a>, you can fix this by declaring the extern shared memory allocation as an aligned <code>char</code> pointer, and then casting it to your desired shared memory type in a separate step:</p>
<pre><span class="highlight-source highlight-c++"><span class="highlight-meta highlight-template highlight-c++"><span class="highlight-storage highlight-type highlight-template highlight-c++">template</span><span class="highlight-punctuation highlight-section highlight-generic highlight-begin highlight-c++">&lt;</span></span><span class="highlight-meta highlight-template highlight-c++"><span class="highlight-storage highlight-type highlight-c++">typename</span> T</span><span class="highlight-meta highlight-template highlight-c++"><span class="highlight-punctuation highlight-section highlight-generic highlight-end highlight-c++">&gt;</span></span>
__global__ <span class="highlight-storage highlight-type highlight-c">void</span> <span class="highlight-meta highlight-function highlight-c++"><span class="highlight-entity highlight-name highlight-function highlight-c++">example</span></span><span class="highlight-meta highlight-function highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span></span></span><span class="highlight-meta highlight-function highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span></span><span class="highlight-meta highlight-function highlight-c++"> </span><span class="highlight-meta highlight-function highlight-c++"><span class="highlight-meta highlight-block highlight-c++"><span class="highlight-punctuation highlight-section highlight-block highlight-begin highlight-c++">{</span></span></span><span class="highlight-meta highlight-function highlight-c++"><span class="highlight-meta highlight-block highlight-c++">
    <span class="highlight-comment highlight-line highlight-double-slash highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">//</span> 16-byte alignment is safe for most types you&#39;ll ever encounter
</span>    <span class="highlight-storage highlight-modifier highlight-c++">extern</span> __shared__ <span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-variable highlight-function highlight-c++">__align__</span><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span></span></span><span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-constant highlight-numeric highlight-c++">16</span></span></span><span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span></span> <span class="highlight-storage highlight-type highlight-c">char</span> shmem_raw<span class="highlight-meta highlight-brackets highlight-c++"><span class="highlight-punctuation highlight-section highlight-brackets highlight-begin highlight-c++">[</span><span class="highlight-punctuation highlight-section highlight-brackets highlight-end highlight-c++">]</span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span> <span class="highlight-comment highlight-line highlight-double-slash highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">//</span> OK
</span>    T <span class="highlight-keyword highlight-operator highlight-c">*</span>shmem <span class="highlight-keyword highlight-operator highlight-assignment highlight-c">=</span> <span class="highlight-keyword highlight-operator highlight-word highlight-cast highlight-c++">reinterpret_cast</span><span class="highlight-punctuation highlight-section highlight-generic highlight-begin highlight-c++">&lt;</span>T <span class="highlight-keyword highlight-operator highlight-c">*</span><span class="highlight-punctuation highlight-section highlight-generic highlight-end highlight-c++">&gt;</span><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span>shmem_raw<span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
    <span class="highlight-comment highlight-block highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">/*</span> ... <span class="highlight-punctuation highlight-definition highlight-comment highlight-c">*/</span></span>
</span></span><span class="highlight-meta highlight-function highlight-c++"><span class="highlight-meta highlight-block highlight-c++"><span class="highlight-punctuation highlight-section highlight-block highlight-end highlight-c++">}</span></span></span>
</span></pre>
<p>(View on Compiler Explorer: <a href="https://godbolt.org/z/zG61rErrP">link</a>)</p>
<h3>Questions</h3>
<p>After you’ve written your GPU scan implementation, you can answer the following question:</p>
<blockquote>
<p><strong>Question 1 for final write-up:</strong> What throughput were you able to achieve with your scan implementation? How did you go about designing your algorithm, and what design did you ultimately end up adopting? Can you describe your implementation in terms of the patterns suggested in the lab instructions? (Or did you do something different?) Did you encounter any interesting bugs along the way? Finally, optionally: can you think of any ways it might be possible to develop an even faster scan implementation?</p>
</blockquote>
<h2>Part 2: Compression</h2>
<p>Now that we’ve implemented our scan algorithm, we’re ready to put it to work!</p>
<p>Our goal in this section will be to implement <a href="https://en.wikipedia.org/wiki/Run-length_encoding"><strong>run-length compression</strong></a> on the GPU. The workload we’re trying to implement can be described by the following sequential Python code:</p>
<pre><span class="highlight-source highlight-python"><span class="highlight-meta highlight-function highlight-python"><span class="highlight-storage highlight-type highlight-function highlight-python">def</span> <span class="highlight-entity highlight-name highlight-function highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">rle_compress</span></span></span><span class="highlight-meta highlight-function highlight-parameters highlight-python"><span class="highlight-punctuation highlight-section highlight-parameters highlight-begin highlight-python">(</span></span><span class="highlight-meta highlight-function highlight-parameters highlight-python"><span class="highlight-variable highlight-parameter highlight-python">raw</span><span class="highlight-punctuation highlight-section highlight-parameters highlight-end highlight-python">)</span></span><span class="highlight-meta highlight-function highlight-python"><span class="highlight-punctuation highlight-section highlight-function highlight-begin highlight-python">:</span></span>
    <span class="highlight-comment highlight-line highlight-number-sign highlight-python"><span class="highlight-punctuation highlight-definition highlight-comment highlight-python">#</span> &#39;raw&#39; is a byte array
</span>    <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">compressed_data</span></span> <span class="highlight-keyword highlight-operator highlight-assignment highlight-python">=</span> <span class="highlight-meta highlight-structure highlight-list highlight-python"><span class="highlight-punctuation highlight-section highlight-list highlight-begin highlight-python">[</span><span class="highlight-punctuation highlight-section highlight-list highlight-end highlight-python">]</span></span>
    <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">compressed_lengths</span></span> <span class="highlight-keyword highlight-operator highlight-assignment highlight-python">=</span> <span class="highlight-meta highlight-structure highlight-list highlight-python"><span class="highlight-punctuation highlight-section highlight-list highlight-begin highlight-python">[</span><span class="highlight-punctuation highlight-section highlight-list highlight-end highlight-python">]</span></span>
    <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">i</span></span> <span class="highlight-keyword highlight-operator highlight-assignment highlight-python">=</span> <span class="highlight-constant highlight-numeric highlight-integer highlight-decimal highlight-python">0</span>
    <span class="highlight-meta highlight-statement highlight-while highlight-python"><span class="highlight-keyword highlight-control highlight-flow highlight-while highlight-python">while</span> <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">i</span></span> <span class="highlight-keyword highlight-operator highlight-comparison highlight-python">&lt;</span> <span class="highlight-meta highlight-function-call highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-support highlight-function highlight-builtin highlight-python">len</span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-begin highlight-python">(</span><span class="highlight-meta highlight-function-call highlight-arguments highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">raw</span></span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-end highlight-python">)</span></span><span class="highlight-punctuation highlight-section highlight-block highlight-while highlight-python">:</span></span>
        <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">c</span></span> <span class="highlight-keyword highlight-operator highlight-assignment highlight-python">=</span> <span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">raw</span></span></span><span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-punctuation highlight-section highlight-brackets highlight-begin highlight-python">[</span></span><span class="highlight-meta highlight-item-access highlight-arguments highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">i</span></span></span><span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-punctuation highlight-section highlight-brackets highlight-end highlight-python">]</span></span>
        <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">run_length</span></span> <span class="highlight-keyword highlight-operator highlight-assignment highlight-python">=</span> <span class="highlight-constant highlight-numeric highlight-integer highlight-decimal highlight-python">1</span>
        <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">i</span></span> <span class="highlight-keyword highlight-operator highlight-assignment highlight-augmented highlight-python">+=</span> <span class="highlight-constant highlight-numeric highlight-integer highlight-decimal highlight-python">1</span>
        <span class="highlight-meta highlight-statement highlight-while highlight-python"><span class="highlight-keyword highlight-control highlight-flow highlight-while highlight-python">while</span> <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">i</span></span> <span class="highlight-keyword highlight-operator highlight-comparison highlight-python">&lt;</span> <span class="highlight-meta highlight-function-call highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-support highlight-function highlight-builtin highlight-python">len</span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-begin highlight-python">(</span><span class="highlight-meta highlight-function-call highlight-arguments highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">raw</span></span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-end highlight-python">)</span></span> <span class="highlight-keyword highlight-operator highlight-logical highlight-python">and</span> <span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">raw</span></span></span><span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-punctuation highlight-section highlight-brackets highlight-begin highlight-python">[</span></span><span class="highlight-meta highlight-item-access highlight-arguments highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">i</span></span></span><span class="highlight-meta highlight-item-access highlight-python"><span class="highlight-punctuation highlight-section highlight-brackets highlight-end highlight-python">]</span></span> <span class="highlight-keyword highlight-operator highlight-comparison highlight-python">==</span> <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">c</span></span><span class="highlight-punctuation highlight-section highlight-block highlight-while highlight-python">:</span></span>
            <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">run_length</span></span> <span class="highlight-keyword highlight-operator highlight-assignment highlight-augmented highlight-python">+=</span> <span class="highlight-constant highlight-numeric highlight-integer highlight-decimal highlight-python">1</span>
            <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">i</span></span> <span class="highlight-keyword highlight-operator highlight-assignment highlight-augmented highlight-python">+=</span> <span class="highlight-constant highlight-numeric highlight-integer highlight-decimal highlight-python">1</span>
        <span class="highlight-meta highlight-function-call highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">compressed_data</span><span class="highlight-punctuation highlight-accessor highlight-dot highlight-python">.</span></span><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-variable highlight-function highlight-python">append</span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-begin highlight-python">(</span><span class="highlight-meta highlight-function-call highlight-arguments highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">c</span></span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-end highlight-python">)</span></span>
        <span class="highlight-meta highlight-function-call highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">compressed_lengths</span><span class="highlight-punctuation highlight-accessor highlight-dot highlight-python">.</span></span><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-variable highlight-function highlight-python">append</span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-begin highlight-python">(</span><span class="highlight-meta highlight-function-call highlight-arguments highlight-python"><span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">c</span></span></span><span class="highlight-punctuation highlight-section highlight-arguments highlight-end highlight-python">)</span></span>
    <span class="highlight-keyword highlight-control highlight-flow highlight-return highlight-python">return</span> <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">compressed_data</span></span>, <span class="highlight-meta highlight-qualified-name highlight-python"><span class="highlight-meta highlight-generic-name highlight-python">compressed_lengths</span></span>
</span></pre>
<p>Given an arbitrary sequence of bytes, we want to find every contiguous run of repeated byte values, and pack the byte value and length of each run into the two arrays <code>compressed_data</code> and <code>compressed_lengths</code>, respectively. For certain kinds of files, such as images containing large blocks of solid color, this simple compression scheme can significantly reduce memory and storage requirements. Below, we show an example of run-length compression applied to a small byte array:</p>
<p><img src="images/rle-intro.svg" alt="" /></p>
<h3>Implementation</h3>
<p>This run-length compression workload is more irregular than anything else we’ve looked at so far in this course, because the <strong>dependency relationships</strong> between memory locations in the input and output buffers aren’t predictable ahead of time. To know <strong>where in the output arrays</strong> you should write information about a given run, you need to know <strong>how many runs</strong> came before it. Nevertheless, it <em>is</em> possible to parallelize this algorithm on the GPU!</p>
<blockquote>
<p><strong>Deliverable:</strong> In the file <code>rle_compress.cu</code>, fill in the function <code>launch_rle_compress</code>, and any associated kernels, to implement run-length compression on the GPU. Aim to process the main benchmark in <code>1.5 ms</code> or less.</p>
</blockquote>
<p>You can find the raw file we’ll be trying to compress here: <a href="images/rle_raw.bmp">link</a>. (You may notice it looks familiar!) The file is approximately 16 million bytes long, and contains some regions with many tightly-packed short runs, as well as other regions with just a few long runs.</p>
<h4>Suggestion: Using Scan</h4>
<p>How you implement your run-length compression algorithm is up to you, but you may find it helpful to consider ways in which you could make use of the <strong>scan</strong> you implemented in Part 1. In particular, you can use a scan to <strong>count runs</strong>. If you construct an auxiliary array which contains a <code>1</code> value at the start of every run, and <code>0</code> elsewhere, then a scan over that array using addition will tell you the cumulative number of runs that have appeared so far at every position in the sequence:</p>
<p><img src="images/rle-scan.svg" alt="" /></p>
<p>Note that you don’t necessarily need to literally create an intermediate boolean array in global memory indicating the boundaries between runs; you could also try to compute those boolean values implicitly as part of some larger computation.</p>
<p>You can feel free to copy your code from Part 1 into <code>rle_compress.cu</code>, and modify it however you see fit to adapt it to the task of run-length compression.</p>
<h4>Tip: Copying Data from GPU to CPU</h4>
<p>When writing your compression implementation, you will likely need to transfer data from the GPU to the CPU at some point. To do this, you can use the function <a href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1gc263dbe6574220cc776b45438fc351e8"><code>cudaMemcpy</code></a>, as in the following code:</p>
<pre><span class="highlight-source highlight-c++"><span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-variable highlight-function highlight-c++">CUDA_CHECK</span><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span></span></span><span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-variable highlight-function highlight-c++">cudaMemcpy</span><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span></span></span><span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-meta highlight-group highlight-c++">
    destination<span class="highlight-punctuation highlight-separator highlight-c++">,</span> <span class="highlight-comment highlight-line highlight-double-slash highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">//</span> pointer to CPU memory
</span>    source<span class="highlight-punctuation highlight-separator highlight-c++">,</span> <span class="highlight-comment highlight-line highlight-double-slash highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">//</span> pointer to GPU memory
</span>    count<span class="highlight-punctuation highlight-separator highlight-c++">,</span> <span class="highlight-comment highlight-line highlight-double-slash highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">//</span> number of bytes to copy
</span>    cudaMemcpyDeviceToHost
</span></span><span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span></span></span></span><span class="highlight-meta highlight-function-call highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
</span></pre>
<p>Calling <code>cudaMemcpy</code> with the argument <code>cudaMemcpyDeviceToHost</code> will automatically <strong>wait</strong> until all previously-launched kernel invocations have run to completion, and then <strong>synchronously</strong> copy the contents of the GPU buffer <code>source</code> to the CPU buffer <code>destination</code>. Because <code>cudaMemcpy</code> runs synchronously, you generally don’t need to worry about subtle concurrency bugs when using it; for most purposes you can think of it just like an ordinary CPU-side <a href="https://cplusplus.com/reference/cstring/memcpy/"><code>memcpy</code></a>.</p>
<p>As you might guess, it’s possible to replace the <code>cudaMemcpyDeviceToHost</code> argument with other values specifying different kinds of data transfers, like <code>cudaMemcpyHostToDevice</code>, or <code>cudaMemcpyDeviceToDevice</code>.</p>
<h3>Questions</h3>
<p>Once you’ve implemented your run-length compression algorithm, you can answer the following questions:</p>
<blockquote>
<p><strong>Question 2 for final write-up:</strong> What run time were you able to achieve with your run-length compression implementation? What over-all design did you end up adopting, and were there any other designs you tried or considered? Did you make use of a scan anywhere in your implementation? Did you encounter any interesting bugs along the way? Optionally: do you have any ideas for how you could make your implementation faster?</p>
</blockquote>
<h2>Part 3: Decompression (Extra Credit)</h2>
<p>If you have time, we encourage you to also try implementing <strong>run-length decompression</strong> on the GPU. This is the exact inverse of the run-length compression from Part 2, with the <code>compressed_data</code> and <code>compressed_length</code> arrays represented in the same format.</p>
<blockquote>
<p><strong>Deliverable (optional, extra credit):</strong> In the file <code>rle_decompress.cu</code>, write the function <code>launch_rle_decompress</code>, and any associated kernels, to implement run-length decompression. Aim to achieve a run time of less than <code>1 ms</code> on both of the benchmarks in the starter code.</p>
</blockquote>
<p>The starter code will benchmark your decompression implementation using two data sources, each of which is roughly 16 million bytes when uncompressed:</p>
<ol>
<li>
<p><a href="images/rle_raw.bmp"><code>rle_raw.bmp</code></a>, the same file as used in the main benchmark for Part 2. This is an image with some regions with many short runs, and some regions with a few long runs.</p>
</li>
<li>
<p>An array of “sparse data,” consisting almost entirely of long runs of bytes of uniform value, with just <code>1024</code> exceptional bytes scattered uniformly at random throughout the file.</p>
</li>
</ol>
<p>How you choose to implement your decompression algorithm is entirely up to you; the features of CUDA we’ve already seen in this course are sufficient to write a fast implementation. Before you get started, though, there is one unusual feature of the starter code which it’s worth taking time to understand, which we discuss below.</p>
<h4>Allocating Workspace Memory</h4>
<p>Because decompression inherently requires allocating unpredictable amounts of memory to hold the decompressed data, we’ve provided you with a slightly different interface for allocating workspace memory for Part 3 of this lab. The arguments passed to the function you’ll be implementing look like this:</p>
<pre><span class="highlight-source highlight-c++">Decompressed <span class="highlight-meta highlight-function highlight-c++"><span class="highlight-entity highlight-name highlight-function highlight-c++">launch_rle_decompress</span></span><span class="highlight-meta highlight-function highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span></span></span><span class="highlight-meta highlight-function highlight-parameters highlight-c++"><span class="highlight-meta highlight-group highlight-c++">
    <span class="highlight-support highlight-type highlight-stdint highlight-c">uint32_t</span> <span class="highlight-variable highlight-parameter highlight-c++">compressed_count</span><span class="highlight-punctuation highlight-separator highlight-c++">,</span>
    <span class="highlight-storage highlight-type highlight-c">char</span> <span class="highlight-storage highlight-modifier highlight-c++">const</span> <span class="highlight-keyword highlight-operator highlight-c">*</span><span class="highlight-variable highlight-parameter highlight-c++">compressed_data</span><span class="highlight-punctuation highlight-separator highlight-c++">,</span>
    <span class="highlight-support highlight-type highlight-stdint highlight-c">uint32_t</span> <span class="highlight-storage highlight-modifier highlight-c++">const</span> <span class="highlight-keyword highlight-operator highlight-c">*</span><span class="highlight-variable highlight-parameter highlight-c++">compressed_lengths</span><span class="highlight-punctuation highlight-separator highlight-c++">,</span>
    GpuAllocCache <span class="highlight-keyword highlight-operator highlight-c">&amp;</span><span class="highlight-variable highlight-parameter highlight-c++">workspace_alloc_1</span><span class="highlight-punctuation highlight-separator highlight-c++">,</span>
    GpuAllocCache <span class="highlight-keyword highlight-operator highlight-c">&amp;</span><span class="highlight-variable highlight-parameter highlight-c++">workspace_alloc_2</span><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span></span><span class="highlight-meta highlight-function highlight-c++">
</span></span></pre>
<p>The <code>GpuAllocCache</code> arguments <code>workspace_alloc_1</code> and <code>workspace_alloc_2</code> allow you to <strong>dynamically</strong> allocate workspace buffers of arbitrary size in the middle of your <code>launch_rle_decompress</code> function. Each <code>GpuAllocCache</code> object automatically maintains its own chunk of allocated GPU memory, which is persistent across calls to <code>launch_rle_decompress</code>. Persisting these allocations across calls allows us to avoid frequent calls to <code>cudaMalloc</code> and <code>cudaFree</code> (which can sometimes be very slow) inside the main benchmarking loop.<sup class="footnote-reference"><a href="#pytorch_alloc">2</a></sup> You can use these objects as follows:</p>
<pre><span class="highlight-source highlight-c++"><span class="highlight-support highlight-type highlight-sys-types highlight-c">size_t</span> workspace_size <span class="highlight-keyword highlight-operator highlight-assignment highlight-c">=</span> <span class="highlight-comment highlight-block highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">/*</span> ... <span class="highlight-punctuation highlight-definition highlight-comment highlight-c">*/</span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
<span class="highlight-storage highlight-type highlight-c">void</span> <span class="highlight-keyword highlight-operator highlight-c++">*</span>my_allocation <span class="highlight-keyword highlight-operator highlight-assignment highlight-c">=</span> workspace_alloc_1<span class="highlight-punctuation highlight-accessor highlight-dot highlight-c++">.</span><span class="highlight-meta highlight-method-call highlight-c++"><span class="highlight-variable highlight-function highlight-member highlight-c++">alloc</span><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span></span></span><span class="highlight-meta highlight-method-call highlight-c++"><span class="highlight-meta highlight-group highlight-c++">workspace_size</span></span><span class="highlight-meta highlight-method-call highlight-c++"><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
</span></pre>
<p>You can only call <code>workspace_alloc_1.alloc</code> and <code>workspace_alloc_2.alloc</code> once each per execution of <code>launch_rle_decompress</code>, because each object can only manage a single contiguous memory allocation.</p>
<h3>Questions</h3>
<p>Once you’ve implemented your decompression implementation, you can answer the final question of the lab:</p>
<blockquote>
<p><strong>Question 3 for final write-up (optional, extra credit):</strong> What run time were you able to achieve on each benchmark with your run-length decompression implementation? What was your design process like, and what design did you end up adopting? Did you notice any differences in what you needed to do to achieve a good run time on each benchmark? Did you encounter any interesting bugs along the way? Do you have any ideas for how you could make your implementation faster?</p>
</blockquote>
<h2>Deliverables</h2>
<h3>Checkpoint (Due Monday, October 28, 2024)</h3>
<p>For the checkpoint for this lab, we ask that you <strong>see how far you can get</strong> on Part 1. You don’t need to finish your scan implementation, but please try to <strong>get started if you can</strong>, so that in live lab we can spend as much time as possible discussing the most interesting aspects of scan algorithms and run-length compression.</p>
<p>On the Gradescope assignment “Lab 7 Checkpoint,” (<a href="https://www.gradescope.com/courses/849967/assignments/5224123/">link</a>) submit your answers to the prompts checking in about how you’re doing with the lab.</p>
<h3>Final Submission (Due Friday, November 1, 2024)</h3>
<p>On the Gradescope assignment “Lab 7 Final,” submit your completed code for <code>scan.cu</code> and <code>rle_compress.cu</code>. If you also completed <code>rle_decompress.cu</code>, you can submit that file as well. Additionally, submit your PDF write-up containing your answers to Questions 1 and 2, and optionally include your answer for Question 3.</p>
<hr />
<div class="footnote-definition" id="monoid"><sup class="footnote-definition-label">1</sup>
<p>In other words, <code>combine</code> and <code>identity</code> together form a <a href="https://en.wikipedia.org/wiki/Monoid">monoid</a>.</p>
</div>
<div class="footnote-definition" id="pytorch_alloc"><sup class="footnote-definition-label">2</sup>
<p>Requesting large chunks of GPU memory up-front using <code>cudaMalloc</code> and then managing them manually in user code is a common pattern in high-performance GPU applications. For example, PyTorch’s caching memory allocator can be seen as implementing a much more sophisticated version of the trick we’re performing with <code>GpuAllocCache</code>: <a href="https://pytorch.org/docs/main/notes/cuda.html#memory-management">link</a>.</p>
</div>
</main><footer><p><a href="https://mit.edu">Massachusetts Institute of Technology</a> —
<a href="https://www.eecs.mit.edu">Department of Electrical Engineering and Computer Science</a></p>
</footer></body></html>