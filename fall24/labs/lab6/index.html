<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><title>6.S894</title><base href="/fall24/labs/lab6/"><meta content="width=device-width, initial-scale=1" name="viewport"><style>@font-face {
    font-family: "Tex Gyre Heros";
    src: url("/fall24/assets/font/tex-gyre-heros/texgyreheros-regular.otf") format("opentype");
    font-weight: regular;
    font-style: regular;
}
@font-face {
    font-family: "Tex Gyre Heros";
    src: url("/fall24/assets/font/tex-gyre-heros/texgyreheros-bold.otf") format("opentype");
    font-weight: bold;
    font-style: regular;
}
@font-face {
    font-family: "Tex Gyre Heros";
    src: url("/fall24/assets/font/tex-gyre-heros/texgyreheros-italic.otf") format("opentype");
    font-weight: regular;
    font-style: italic;
}
@font-face {
    font-family: "Tex Gyre Heros";
    src: url("/fall24/assets/font/tex-gyre-heros/texgyreheros-bolditalic.otf") format("opentype");
    font-weight: bold;
    font-style: italic;
}</style><link href="/fall24/assets/main.css" rel="stylesheet"><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" rel="stylesheet"><link href="/fall24/assets/favicon.png" rel="icon" type="image/png"></head><body><header><nav><h1><a href="/fall24/">6.S894</a></h1>
<p><a href="/fall24/calendar">Calendar</a></p>
<p><a href="/fall24/labs">Labs</a></p>
<p><a href="/fall24/syllabus">Syllabus</a></p>
<p><a href="/fall24/resources">Resources</a></p>
<p><a href="/fall24/contact">Contact</a></p>
<p><a href="/fall24/piazza">Piazza</a></p>
</nav></header><main><h1>Lab 6: Matrix Multiply – Tensor Cores</h1>
<h2>Prologue: Logistics</h2>
<h3>Due Dates</h3>
<p>For this lab, you’ll be turning in the following deliverables:</p>
<ul>
<li>
<p><strong>Checkpoint:</strong> Due Monday, October 21, 11:59pm (<a href="https://www.gradescope.com/courses/849967/assignments/5181469/">Gradescope</a>)</p>
</li>
<li>
<p><strong>Final Submission:</strong> Due Friday, October 25, 11:59pm (<a href="https://www.gradescope.com/courses/849967/assignments/5181509/">Gradescope</a>)</p>
</li>
</ul>
<p>See the “Deliverables” section at the end of this document for more information on what you’ll be turning in.</p>
<h3>Starter Code</h3>
<p>You can get the starter code for this lab by cloning the <a href="https://github.com/accelerated-computing-class/lab6">lab repository</a>:</p>
<pre><span class="highlight-source highlight-shell highlight-bash"><span class="highlight-meta highlight-function-call highlight-shell"><span class="highlight-variable highlight-function highlight-shell">git</span></span><span class="highlight-meta highlight-function-call highlight-arguments highlight-shell"> clone git@github.com:accelerated-computing-class/lab6.git</span>
</span></pre>
<blockquote>
<p><strong>Update October 18:</strong> The starter code has been updated since its initial release, and now includes the file <a href="https://github.com/accelerated-computing-class/lab6/blob/main/matmul_3.cu"><code>matmul_3.cu</code></a> for Part 3. If you cloned the repo before this update, please pull the latest commit, or manually copy the new <code>matmul_3.cu</code> file to your computer. (<a href="https://raw.githubusercontent.com/accelerated-computing-class/lab6/refs/heads/main/matmul_3.cu">link to raw file</a>)</p>
</blockquote>
<h2>Introduction</h2>
<h3>Goals for This Lab</h3>
<p>So far in our exploration of matrix multiplication, we’ve focused primarily on optimizing <strong>data movement</strong> (<a href="/fall24/labs/lab4">Lab 4</a>) and <strong>work partitioning</strong> (<a href="/fall24/labs/lab5">Lab 5</a>). As we’ve worked to reduce bottlenecks along those dimensions, the run times of our implementations have increasingly become dominated by the cost of the <strong>floating point computations</strong> in our kernels’ innermost loops. Up until now, we’ve been implementing those core floating point computations using <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/#floating-point-instructions-fma"><strong>fused multiply-add (FMA)</strong></a> instructions. However, we can do better: modern NVIDIA GPUs support so-called <a href="https://www.nvidia.com/en-us/data-center/tensor-cores/">“<strong>tensor core</strong>”</a> instructions, which are designed specifically to accelerate matrix multiplication workloads. In this third and final matrix multiplication lab, we’ll be looking at how to use those tensor core instructions to speed up our kernels.</p>
<p>The tensor core instructions we’ll be using in this lab aren’t exposed by default in the CUDA C++ language, so we’ll be accessing them via <a href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html"><strong>inline PTX assembly</strong></a>.<sup class="footnote-reference"><a href="#cutlass">1</a></sup> Since we haven’t worked with inline PTX before, this lab will walk through how to make use of tensor core instructions step-by-step:</p>
<ol>
<li>
<p>The first part of this lab is a brief <strong>introduction to inline PTX</strong>, using a simple <strong>bit manipulation</strong> instruction as an example.</p>
</li>
<li>
<p>Next, we’ll look at how to access <strong>tensor core instructions</strong> in PTX, and how to work with the <strong>data layouts</strong> those tensor core instructions expect.</p>
</li>
<li>
<p>Finally, we’ll integrate tensor core instructions into our <strong>full matrix multiplication kernel</strong>, and try to obtain a speedup over what were able to achieve using FMAs.</p>
</li>
</ol>
<h3>Note on Terminology: What is a “Tensor Core?”</h3>
<p>Although the phrase “tensor core” might conjure up mental images of something similar to a “CPU core” – perhaps something with its own register file and program counter, decoding and executing a programmable stream of instructions in sequence – a tensor core is <strong>not</strong> actually that kind of “core” in the traditional computer architecture sense.</p>
<p>The phrase “tensor core” is just NVIDIA’s name for a particular kind of <strong>functional unit</strong> which exists on recent generations of NVIDIA GPUs. Tensor cores are not fundamentally different from ALUs or FPUs – each tensor core is attached to a warp scheduler, and solely executes math operations.</p>
<p><img src="images/tensor_core_schematic.svg" alt="" /></p>
<p>From a software point of view, tensor cores simply provide <strong>another kind of math instruction</strong> which your code is able to invoke. As we’ll see, these tensor core instructions have some interesting and unusual properties, but their existence doesn’t radically alter anything about the CUDA programming model.</p>
<h2>Part 1: Warm-Up – Introduction to Inline PTX</h2>
<p>Before attempting to use tensor cores, we’ll look at an example of how to use inline PTX to access a simpler instruction: the <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/#logic-and-shift-instructions-lop3"><strong><code>lop3</code></strong></a> instruction, which stands for “<a href="https://en.wikipedia.org/wiki/Holland_Lop">Logical Operation</a> on 3 Inputs.”</p>
<p>The <code>lop3</code> instruction generalizes bit-wise operations like <code>&amp;</code>, <code>|</code>, <code>~</code>, and <code>^</code>. It computes an arbitrary bit-wise function of three 32-bit integer inputs (per CUDA thread), with the exact behavior of the bit-wise function determined by a programmer-supplied <strong>lookup table</strong>. Because there are only <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">2^3 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> possible tuples of three bits, the full contents of this lookup table can be encoded in a single 8-bit integer. In this exercise, we’ll be looking at how to use <code>lop3</code> to compute the specific bit-wise operation <code>(a &amp; b) | c</code>, the <code>lop3</code> lookup table for which can be expressed using the constant <code>0b11101010</code>.</p>
<p>The <code>lop3</code> instruction can be useful in applications requiring bit-level manipulation, such as when <a href="https://arxiv.org/abs/2408.11743">decompressing neural network weights from 4-bit to 16-bit precision</a> (search for “lop3” in that paper!). However, the CUDA C++ language does not by default expose any way to explicitly invoke <code>lop3</code> from user code.<sup class="footnote-reference"><a href="#lop3_opt">2</a></sup> To access it, we’ll need to use inline PTX.</p>
<p>To embed inline PTX in our CUDA programs, we can use the <code>asm(...)</code> construct, which looks like this:</p>
<pre><span class="highlight-source highlight-c++"><span class="highlight-storage highlight-type highlight-c">asm</span><span class="highlight-meta highlight-group highlight-c++"><span class="highlight-punctuation highlight-section highlight-group highlight-begin highlight-c++">(</span>
    <span class="highlight-string highlight-quoted highlight-double highlight-c"><span class="highlight-punctuation highlight-definition highlight-string highlight-begin highlight-c">&quot;</span> snippet of PTX code, with &#39;holes&#39; to fill in <span class="highlight-punctuation highlight-definition highlight-string highlight-end highlight-c">&quot;</span></span>
    <span class="highlight-keyword highlight-operator highlight-ternary highlight-c">:</span> <span class="highlight-comment highlight-block highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">/*</span> output variables to associate with holes <span class="highlight-punctuation highlight-definition highlight-comment highlight-c">*/</span></span>
    <span class="highlight-keyword highlight-operator highlight-ternary highlight-c">:</span> <span class="highlight-comment highlight-block highlight-c"><span class="highlight-punctuation highlight-definition highlight-comment highlight-c">/*</span> input variables to associate with holes <span class="highlight-punctuation highlight-definition highlight-comment highlight-c">*/</span></span>
<span class="highlight-punctuation highlight-section highlight-group highlight-end highlight-c++">)</span></span><span class="highlight-punctuation highlight-terminator highlight-c++">;</span>
</span></pre>
<p>You can read about CUDA’s inline PTX syntax in detail here: <a href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html">inline PTX syntax docs</a>. For our purposes, the following should be sufficient:</p>
<ul>
<li>
<p>The <code>lop3</code> instruction we want to invoke can be written using the PTX string</p>
<pre><span class="highlight-source highlight-c++"><span class="highlight-string highlight-quoted highlight-double highlight-c"><span class="highlight-punctuation highlight-definition highlight-string highlight-begin highlight-c">&quot;</span>lop3.b32 %0, %1, %2, %3, 0b11101010;<span class="highlight-punctuation highlight-definition highlight-string highlight-end highlight-c">&quot;</span></span>
</span></pre>
<ul>
<li>
<p>The identifier <code>lop3.b32</code> is the full name of the instruction, with the suffix <code>b32</code> indicating that it’s meant to operate on 32-bit values.</p>
</li>
<li>
<p>The percent-prefixed numbers <code>%0</code>, <code>%1</code>, <code>%2</code>, <code>%3</code> are “holes” in the PTX string, which will be replaced with references to specific PTX registers during compilation. We’ll need to associate each hole with a variable from the surrounding CUDA program in order for the compiler to know which register names it should plug in for the final PTX.</p>
</li>
<li>
<p>The <code>%0</code> operand is the destination register, and the <code>%1</code>, <code>%2</code>, <code>%3</code> operands are the source registers (PTX is more like <a href="https://imada.sdu.dk/u/kslarsen/dm546/Material/IntelnATT.htm">“Intel syntax”</a> than <a href="https://imada.sdu.dk/u/kslarsen/dm546/Material/IntelnATT.htm">“AT&amp;T syntax”</a>).</p>
</li>
<li>
<p>The constant <code>0b11101010</code> encodes the lookup table corresponding to the bit-wise operation <code>(a &amp; b) | c</code>.</p>
</li>
<li>
<p>Note the <strong>quotes</strong>, and the final <strong>semicolon</strong> in the PTX <strong>inside</strong> the quotes!</p>
</li>
</ul>
</li>
<li>
<p>To specify an output variable, use either the syntax <code>"=&lt;type-abbreviation&gt;"(var_name)</code> or <code>"+&lt;type-abbreviation&gt;"(var_name)</code></p>
<ul>
<li>
<p>Use <code>=</code> if the output operand is only written to by the instruction, and <code>+</code> if it is both read from and written to. (In the case of <code>lop3.b32</code>, and for the tensor core instructions we’ll be seeing later, the output operands are only written to.)</p>
</li>
<li>
<p>Replace <code>&lt;type-abbreviation&gt;</code> with a letter indicating the type of the register. For 32-bit integer registers, the appropriate letter is <code>r</code>. You can find the letters corresponding to other types of registers in the <a href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html#constraints">inline PTX docs</a>.</p>
</li>
<li>
<p>In our case, this will look something like <code>"=r"(var_name)</code>, where <code>var_name</code> is some <code>uint32_t</code> variable from the surrounding scope in your CUDA program.</p>
</li>
</ul>
</li>
<li>
<p>To specify an input variable, use just <code>"&lt;type-abbreviation&gt;"(var_name)</code>, without the leading <code>=</code> or <code>+</code>.</p>
<ul>
<li>
<p>In our case, this will look something like <code>"r"(var_name)</code>.</p>
</li>
<li>
<p>When you have multiple input or output variables in an <code>asm</code> statement, you can separate them with commas, like <code>"r"(var_a), "r"(var_b), "r"(var_c)</code>.</p>
</li>
</ul>
</li>
</ul>
<p>Now we’re ready to write some inline PTX!</p>
<blockquote>
<p><strong>Deliverable:</strong> In the file <code>exercise_lop3.cu</code>, fill in the body of the function <code>lop3_kernel</code> to perform the operation <code>*out = (*a &amp; *b) | *c;</code> using the <code>lop3.b32</code> instruction, invoked via inline PTX.</p>
</blockquote>
<blockquote>
<p><strong>Question 1 for final write-up:</strong> Look at the assembly code generated for your <code>exercise_lop3.cu</code> file, using either <a href="https://godbolt.org/z/Pbf494Tzd">Compiler Explorer</a> or the <code>--asm</code> flag in Telerun. What does the generated PTX for your kernel look like? Specifically, what happened to the “holes” in the inline PTX string? What does the generated SASS look like?</p>
</blockquote>
<h2>Part 2: Warm-Up – Invoking Tensor Core Instructions</h2>
<p>Now that we’ve looked at how inline PTX works, we can start using it to interact with the tensor cores on our GPU!</p>
<p>The RTX A4000 GPU we’re using belongs to NVIDIA’s <a href="https://en.wikipedia.org/wiki/Ampere_(microarchitecture)">Ampere</a> generation (specifically, “Compute Capability 8.6”). On Ampere, there are tensor core instructions available in three different floating-point flavors:</p>
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format"><strong><code>f16</code></strong></a> – The 16-bit floating point format <a href="https://en.wikipedia.org/wiki/IEEE_754">defined by the IEEE 754 standard</a>, with 5 exponent bits and 10 mantissa bits.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Bfloat16_floating-point_format"><strong><code>bf16</code></strong></a> – “<a href="https://en.wikipedia.org/wiki/Google_Brain">Brain</a> float 16,” with 8 exponent bits and 7 mantissa bits. Popular in deep learning.</p>
</li>
<li>
<p><a href="https://blogs.nvidia.com/blog/tensorfloat-32-precision-format/"><strong><code>tf32</code></strong></a> – “TensorFloat-32,” which is basically ordinary <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">32-bit floating point</a>, but with compromises made in the accuracy of the multiplications performed by the tensor core. The mantissa of each input value is implicitly truncated to 10 bits (down from the ordinary 23) before participating in the multiplication.</p>
</li>
</ul>
<p>Additionally, for all three of these formats, tensor cores support <strong>accumulating</strong> results in full 32-bit precision, effectively casting the results of the tensor core’s lower-precision multiplications up to FP32 before adding them together or to an existing partial sum.</p>
<p>Because the kernels we developed in Lab 4 and Lab 5 work in 32-bit precision, we’ll be focusing on <strong>TF32</strong> precision in this lab for the sake of compatibility with our existing code. Given that TF32 tensor core instructions perform multiplications in lower precision than the FP32 FMAs we’ve been using until now, we can expect to see some unavoidable accuracy loss when we adapt our kernel to use tensor cores.</p>
<p>So – what kind of TF32-precision tensor core functionality do we actually have on our A4000 GPU? The answer is simple – we have exactly two instructions:<sup class="footnote-reference"><a href="#wmma">3</a></sup></p>
<ul>
<li><strong><code>mma.sync.aligned.m16n8k4.row.col.f32.tf32.tf32.f32</code></strong> (<code>HMMA.1684.F32.TF32</code> in SASS)</li>
<li><strong><code>mma.sync.aligned.m16n8k8.row.col.f32.tf32.tf32.f32</code></strong> (<code>HMMA.1688.F32.TF32</code> in SASS)</li>
</ul>
<p>(You can find the PTX documentation for these instructions here: <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/#multiply-and-accumulate-instruction-mma">MMA PTX docs</a>.)</p>
<p>Both of these instructions are “<strong>matrix-multiply-accumulate</strong>” (<strong>MMA</strong>) instructions; conceptually, they each implement an operation like:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mo>←</mo><mi>A</mi><mi>B</mi><mo>+</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">D \leftarrow A B + C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span></p>
<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> are matrices. The two instructions differ only in the dimensions of the matrices they operate on:</p>
<div class="table-container"><table><thead><tr><th>Instruction Dimensions</th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> Dimensions</th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> Dimensions</th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> Dimensions</th></tr></thead><tbody>
<tr><td><code>m16n8k4</code></td><td><code>16 * 4</code></td><td><code>4 * 8</code></td><td><code>16 * 8</code></td></tr>
<tr><td><code>m16n8k8</code></td><td><code>16 * 8</code></td><td><code>8 * 8</code></td><td><code>16 * 8</code></td></tr>
</tbody></table>
</div>
<p>Empirically, the course staff have observed that these instructions are equivalent in terms of FLOP throughput; the <code>m16n8k4</code> variant performs half as much work per instruction as <code>m16n8k8</code>, but twice as many <code>m16n8k4</code> instructions can execute per cycle on average as <code>m16n8k8</code>.</p>
<p>In this part of the lab, we’ll look at how we can use the <strong><code>m16n8k8</code></strong> TF32 MMA instruction to execute a <strong>single <code>16 * 8 * 8</code> matrix multiplication</strong>. As we’ll see, this isn’t actually trivial – in particular, it will require understanding the unusual way in which tensor core instructions expect their operands to be laid out in registers.</p>
<h3>Warp-Level Semantics</h3>
<p>To understand how the <code>mma.sync.aligned.m16n8k8.row.col.f32.tf32.tf32.f32</code> instruction works, the most important fact to establish is that tensor core instructions fundamentally operate <strong>at the warp level</strong>.</p>
<p>As we saw in Labs 1 and 2, the GPU’s hardware always executes instructions in a 32-wide SIMD fashion, with every 32 consecutive CUDA threads grouped together as 32 lanes of a vector. Viewing the GPU as a SIMD machine, virtually all the instructions we’ve seen our GPU execute so far in this course have been <strong>element-wise vector operations</strong>, with each instruction applying an <strong>identical, independent</strong> operation in each lane (modulo masking). When every instruction we execute is element-wise, we can often get away with ignoring the fact that the GPU is a SIMD machine at all, and simply pretend like every CUDA thread its executing its own independent stream of instructions. However, tensor core instructions <strong>break this illusion</strong>, because they are <strong>not element-wise</strong>.<sup class="footnote-reference"><a href="#illusion">4</a></sup></p>
<p>When a warp executes a tensor core operation like our <code>m16n8k8</code> instruction, it is not executing a separate, independent matrix multiplication for each CUDA thread in the warp; rather, it is executing a <strong>single <code>16 * 8 * 8</code> matrix multiplication</strong> cooperatively across the <strong>entire warp</strong>, with the input and output data for the instruction <strong>distributed</strong> across the registers of all the CUDA threads in the warp. When thinking about tensor core instructions, it’s most helpful to think of each “register” in your program as a <strong>32-word-wide vector register</strong>, rather than as a single scalar register per CUDA thread.</p>
<p>With all of that in mind, let’s take a look at how the <code>m16n8k8</code> instruction we’re using actually expects data to be laid out in registers. First, a bit of math:</p>
<ul>
<li>The <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> matrix is <code>16 * 8</code> words, so we need <code>16 * 8 / 32 = 4</code> registers to store it.</li>
<li>The <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> matrix is <code>8 * 8</code> words, so we need <code>8 * 8 / 32 = 2</code> registers to store it.</li>
<li>The <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> matrix is <code>16 * 8</code> words, so we need <code>16 * 8 / 32 = 4</code> registers to store it.</li>
</ul>
<p>Accordingly, the PTX syntax for invoking our tensor core instruction looks like this:</p>
<pre><code>mma.sync.aligned.m16n8k8.row.col.f32.tf32.tf32.f32
    {%0, %1, %2, %3},     /* 'D' matrix */
    {%4, %5, %6, %7},     /* 'A' matrix */
    {%8, %9},             /* 'B' matrix */
    {%10, %11, %12, %13}; /* 'C' matrix */
</code></pre>
<p>(PTX syntax supports <code>/* ... */</code> comments.)</p>
<p>From the perspective of each CUDA thread, each of these <code>%0</code>, <code>%1</code>, etc operands is a <strong>1-word scalar register</strong>. Collectively across the entire warp, each operand is a <strong>32-word vector register</strong>.</p>
<p>How does the <code>m16n8k8</code> instruction expect data to be packed into these registers? We present the layouts below.</p>
<p><a href="images/tf32_16x8x8_a.png"><img src="images/tf32_16x8x8_a.png" alt="" /></a></p>
<p><a href="images/tf32_16x8x8_b.png"><img src="images/tf32_16x8x8_b.png" alt="" /></a></p>
<p><a href="images/tf32_16x8x8_c.png"><img src="images/tf32_16x8x8_c.png" alt="" /></a></p>
<p>(These diagrams are courtesy of <a href="https://claude.ai/">Claude 3.5 Sonnet</a>. You can click any image to expand it. You can also access <strong>interactive</strong> versions of these diagrams here:</p>
<ul>
<li><a href="https://claude.site/artifacts/395b764a-dfdf-41c4-81ea-bd2a9776af5e"><strong>interactive ‘A’</strong></a></li>
<li><a href="https://claude.site/artifacts/7c09e2c1-7381-46a3-a1e3-2151d5f34c58"><strong>interactive ‘B’</strong></a></li>
<li><a href="https://claude.site/artifacts/ff994c5b-a8d7-4eec-b345-82ff73b59d17"><strong>interactive ‘C’</strong></a>
)</li>
</ul>
<p>(The <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-1688">PTX documentation</a> also contains its own versions of these diagrams.)</p>
<p>Essentially:</p>
<ul>
<li>
<p>The ‘A’ matrix is split into 4 quadrants. Each quadrant is mapped to a separate register, first top-to-bottom then left-to-right. Within each quadrant, the data is laid out in the corresponding register in row-major order.</p>
</li>
<li>
<p>The ‘B’ matrix is split vertically into 2 halves. Each half is mapped to a separate register, first top then bottom. Within each half, the data is laid out in the corresponding register in column-major order.</p>
</li>
<li>
<p>The ‘C’ matrix (and ‘D’ matrix) is split vertically into 2 halves, and each half is sliced into alternating vertical stripes, with all the even stripes grouped together and all the odd stripes grouped together. Each stripe-set in each half is mapped to a separate register. Within each stripe-set, the data is laid out in the corresponding register in row-major order.</p>
</li>
</ul>
<p>Recall that for the ‘A’ matrix, the “vertical” and “horizontal” dimensions correspond to the <code>i</code> and <code>k</code> indices in the matrix multiply computation, whereas for ‘B’ they correspond to the <code>k</code> and <code>j</code> indices, and for ‘C’ they correspond to <code>i</code> and <code>j</code>.</p>
<h3>A Note on Register Types</h3>
<p>You now have almost everything you need in order to invoke the <code>mma.sync.aligned.m16n8k8.row.col.f32.tf32.tf32.f32</code> instruction to perform a <code>16 * 8 * 8</code> matrix-multiply-accumulate. There is, however, one remaining quirk of the PTX interface to be aware of: this PTX instruction expects every operand to be a 32-bit <strong>integer</strong> register. Of course, the bits these integer values carry will actually encode 32-bit floating-point data, but it expects them to be integer registers nonetheless. To cope with this, you can use the built-in <a href="https://docs.nvidia.com/cuda/cuda-math-api/cuda_math_api/group__CUDA__MATH__INTRINSIC__CAST.html#_CPPv415__float_as_uintf"><code>__float_as_uint</code></a> and <a href="https://docs.nvidia.com/cuda/cuda-math-api/cuda_math_api/group__CUDA__MATH__INTRINSIC__CAST.html#_CPPv415__uint_as_floatj"><code>__uint_as_float</code></a> functions to reinterpret the bits of a <code>float</code> as a <code>uint32_t</code>, and vice-versa. (These conversion functions are purely a compile-time formality and should ultimately have zero cost at run time.)</p>
<h3>Implementation</h3>
<blockquote>
<p><strong>Deliverable:</strong> In the file <code>exercise_mma.cu</code>, implement the function <code>mma_16x8x8_kernel</code> to perform a single <code>16 * 8 * 8</code> matrix multiplication on the matrices stored in <code>a</code> and <code>b</code>, and accumulate the results of that matrix multiplication into <code>c</code>, using the tensor core instruction <code>mma.sync.aligned.m16n8k8.row.col.f32.tf32.tf32.f32</code>. In addition to invoking this tensor core instruction, your kernel can use whatever additional CUDA logic you like to compute indices, move data around, etc. The data in <code>a</code>, <code>b</code>, and <code>c</code> is stored in row-major layout in global memory. Note that the kernel <code>mma_16x8x8_kernel</code> will be launched with exactly 32 CUDA threads (one warp).</p>
</blockquote>
<blockquote>
<p><strong>Question 2 for final write-up:</strong> Look at the assembly code generated for your <code>exercise_mma.cu</code> file. What does the generated SASS look like? Can you find the tensor core instruction?</p>
</blockquote>
<h2>Part 3: Accelerating Matrix Multiply</h2>
<p>Now that we’ve seen how to invoke tensor core instructions on our GPU, we’re ready to integrate them into our full matrix multiply kernel!</p>
<p>For this lab, we’ll be focusing on just a subset of the problem sizes from Lab 5. Here they are:</p>
<div class="table-container"><table><thead><tr><th><code>size_i</code></th><th><code>size_j</code></th><th><code>size_k</code></th></tr></thead><tbody>
<tr><td><code>3072</code></td><td><code>3072</code></td><td><code>3072</code></td></tr>
<tr><td><code> 512</code></td><td><code>3072</code></td><td><code>3072</code></td></tr>
<tr><td><code> 256</code></td><td><code>3072</code></td><td><code>3072</code></td></tr>
<tr><td><code> 128</code></td><td><code>3072</code></td><td><code>3072</code></td></tr>
<tr><td><code>  64</code></td><td><code>3072</code></td><td><code>3072</code></td></tr>
<tr><td><code>  32</code></td><td><code>3072</code></td><td><code>3072</code></td></tr>
<tr><td><code>  16</code></td><td><code>3072</code></td><td><code>3072</code></td></tr>
</tbody></table>
</div>
<h3>Analysis</h3>
<p>To understand the maximum performance we can achieve with our tensor core implementation on each of these problem sizes, we can repeat a similar analysis to the one we carried out for the previous lab. For this analysis, you can assume that the theoretical peak TF32 tensor core throughput on our A4000 GPU is given by:</p>
<pre><code>  (128 FLOP / tensor core / cycle)
* (4 tensor cores / SM)
* (48 SMs)
* (1.56 GHz)

= 38.34 TFLOP/s
</code></pre>
<blockquote>
<p><strong>Question 3 for final write-up:</strong> For <strong>each of the problem sizes</strong> in this lab, walk through the following analysis (you may find it helpful to reuse some of your calculations from <a href="/fall24/labs/lab5">Lab 5</a> Question 2):</p>
<ol>
<li>
<p>Considering the total number of FLOPs required to process this problem size, what is the fastest we could process this problem size if <strong>tensor core throughput</strong> were the only constraint?</p>
</li>
<li>
<p>Considering (1) as well as the minimum time required to access each unique matrix element in DRAM, what <strong>lower bound</strong> does this imply for the run time of our algorithm? Is this workload compute-bound or bandwidth-bound?</p>
</li>
<li>
<p>Considering (2), what is the <strong>maximum TFLOP/s</strong> we could achieve on this problem size? (This is just (2) divided by the total FLOPs.)</p>
</li>
<li>
<p>How does (3) <strong>compare</strong> to the maximum throughput achievable if we were to use <strong>FMAs</strong> rather than tensor cores (as we calculated in Lab 5 Question 2.6)? Is the workload constrained by the same resource (either compute or bandwidth) in both cases, or is one scenario compute-bound while the other is bandwidth-bound?</p>
</li>
</ol>
</blockquote>
<h3>Implementation</h3>
<p>Our goal for the final part of this lab will be to write a matrix multiply kernel which uses <strong>tensor cores</strong> to run <strong>faster than any FMA-based matrix multiply realistically could</strong> on our largest problem sizes.</p>
<p>To calibrate our expectations for how fast an FMA-based kernel could realistically run, we’ve measured the performance of NVIDIA’s highly-optimized <a href="https://developer.nvidia.com/cublas">cuBLAS library</a> on each problem size <strong>when running without tensor cores</strong>:<sup class="footnote-reference"><a href="#cublas_fp32">5</a></sup></p>
<p><strong>cuBLAS Performance Without Tensor Cores:</strong></p>
<div class="table-container"><table><thead><tr><th><code>size_i</code></th><th><code>size_j</code></th><th><code>size_k</code></th><th>Time (ms)</th><th>Throughput (TFLOP/s)</th></tr></thead><tbody>
<tr><td><code>3072</code></td><td><code>3072</code></td><td><code>3072</code></td><td><code>4.05</code></td><td><code>14.32</code></td></tr>
<tr><td><code>512</code></td><td><code>3072</code></td><td><code>3072</code></td><td><code>0.80</code></td><td><code>12.07</code></td></tr>
<tr><td><code>256</code></td><td><code>3072</code></td><td><code>3072</code></td><td><code>0.46</code></td><td><code>10.40</code></td></tr>
<tr><td><code>128</code></td><td><code>3072</code></td><td><code>3072</code></td><td><code>0.24</code></td><td><code>10.00</code></td></tr>
<tr><td><code>64</code></td><td><code>3072</code></td><td><code>3072</code></td><td><code>0.13</code></td><td><code>9.57</code></td></tr>
<tr><td><code>32</code></td><td><code>3072</code></td><td><code>3072</code></td><td><code>0.11</code></td><td><code>5.26</code></td></tr>
<tr><td><code>16</code></td><td><code>3072</code></td><td><code>3072</code></td><td><code>0.11</code></td><td><code>2.73</code></td></tr>
</tbody></table>
</div>
<p>Our goal will be to write an implementation which beats these non-tensor-core cuBLAS numbers on the <strong>following problem sizes:</strong></p>
<ul>
<li><code>3072 * 3072 * 3072</code></li>
<li><code>512 * 3072 * 3072</code></li>
<li><code>256 * 3072 * 3072</code></li>
<li><code>128 * 3072 * 3072</code></li>
</ul>
<p>For the other problem sizes, your implementation should be correct, but it’s okay if it achieves worse performance than cuBLAS.</p>
<blockquote>
<p><strong>Deliverable:</strong> In the file <a href="https://github.com/accelerated-computing-class/lab6/blob/main/matmul_3.cu"><code>matmul_3.cu</code></a>, implement the function <code>launch_matmul_tensor</code>, and any associated kernels, so that when <code>size_i</code> is <code>3072</code>, <code>512</code>, <code>256</code>, or <code>128</code>, it achieves a higher throughput than our FMA-based cuBLAS baseline. To do this, you will (almost certainly) need to use tensor cores.</p>
</blockquote>
<p>To hit this performance target, you don’t need any techniques other than what we’ve already discussed in Lab 4, Lab 5, and this lab. All the suggestions from the previous labs continue to apply; a few especially important ones which you may find it helpful to keep in mind are:</p>
<ul>
<li>
<p><strong>Avoid register spills</strong>, by not exceeding the register file capacity and by not accessing arrays using dynamic indices.</p>
</li>
<li>
<p><strong>Use microtiles for register-level reuse.</strong> This is still relevant when using tensor cores! (But how should you structure the microtiles now?)</p>
</li>
<li>
<p><strong>Overlap data movement with computation</strong>, using e.g. asynchronous copy instructions.</p>
</li>
<li>
<p><strong>Avoid many-way bank conflicts</strong>, either by adjusting your data layouts or by adjusting your access patterns.</p>
</li>
</ul>
<p>Good luck! Once you’ve implemented your optimized kernel, you can answer the final question of the lab:</p>
<blockquote>
<p><strong>Question 4 for final write-up:</strong> How does the performance of your implementation compare to the cuBLAS FMA baseline for each problem size? What fraction of theoretical peak throughput (calculated in Question 3.3) were you able to achieve for each problem size? What did you need to change about your kernel design in order to make use of tensor core instructions? What RRMSE numbers do you observe for your implementation, and how do they compare to the RRMSE numbers for your non-tensor-core implementation from Lab 5? Did you encounter any interesting bugs along the way? Finally, optionally: do you have any ideas for how it might be possible to develop an implementation which runs even faster?</p>
</blockquote>
<p>Congratulations – you’ve reached the end of the matrix multiplication labs for 6.S894! We hope you’ve had as much fun working through them as we’ve had creating them.</p>
<p>You’re now well on your way to being able to implement the kinds of high-performance matrix multiplication kernels which power the world’s most computationally demanding deep learning applications, as well as important applications in many other domains.</p>
<h2>Further Reading</h2>
<p>If you want to learn more about matrix multiplication, there are a huge number of additional topics you may find it interesting to look into, including:</p>
<ul>
<li>
<p><strong>Reduced precisions:</strong></p>
<ul>
<li>
<p>The tensor cores on our GPU support 16-bit floating point (<a href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-1688">PTX docs</a>), 8-bit integer (<a href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-16816-i8">PTX docs</a>), and 4-bit integer (<a href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-fragment-mma-16832">PTX docs</a>) precisions. Handling these precisions efficiently poses new and interesting challenges, like needing to pack multiple values into each 32-bit word (<a href="https://docs.nvidia.com/cuda/cuda-math-api/struct____nv__bfloat162.html">CUDA docs</a>).</p>
</li>
<li>
<p>Newer architectures, like Hopper, also support 8-bit floating point, and NVIDIA’s upcoming Blackwell GPUs will support exotic formats like 4-bit floating point and 6-bit (!) floating point (<a href="https://www.anandtech.com/show/21310/nvidia-blackwell-architecture-and-b200b100-accelerators-announced-going-bigger-with-smaller-data">link</a>).</p>
</li>
</ul>
</li>
<li>
<p><strong>Fused and variant kernels:</strong></p>
<ul>
<li>It’s very common for high-performance machine learning applications to employ kernels which implement matrix multiplication <strong>combined with some other operation</strong>. This can look like applying an element-wise operation or a reduction on the final output of a matrix multiplication before writing it back to DRAM (<a href="https://dl.acm.org/doi/pdf/10.1145/3620666.3651369">relevant paper</a>), but it also includes even more complicated kernel designs like FlashAttention (<a href="https://arxiv.org/abs/2205.14135">link</a>, and <a href="https://arxiv.org/abs/2407.08608">state-of-the art version</a>) which embed matrix-multiply-like computations inside other kinds of workloads. An interesting recent example is FLUX (<a href="https://arxiv.org/abs/2406.06858v4">link</a>), which combines matrix multiplication with cross-GPU communication.</li>
</ul>
</li>
<li>
<p><strong>Higher-level tools:</strong></p>
<ul>
<li>In this lab we’ve been programming the GPU at a very low level of abstraction, but it’s also possible, and often preferable, to write matrix multiplications using higher-level CUDA libraries like CUTLASS (<a href="https://github.com/NVIDIA/cutlass">link</a>), or domain-specific languages like Triton (<a href="https://triton-lang.org/main/index.html">link</a>). Many of the performance optimizations used in the implementations of those tools are techniques that you now know how to implement by hand!</li>
</ul>
</li>
<li>
<p><strong>Improved scheduling and partitioning:</strong></p>
<ul>
<li>NVIDIA’s best-performing matrix multiply kernels use techniques slightly more advanced than (but very similar to!) the ideas we’ve discussed in these past three labs. Some of the key differences from the designs we’ve covered include overlapping data movement with computation using software pipelines with more than two stages (i.e. staging data into a ring buffer rather than double-buffering it) (<a href="https://github.com/NVIDIA/cutlass/blob/main/media/docs/efficient_gemm.md">link</a>), and using partitioning strategies which achieve better load-balancing than split-k, such as “stream-k” (<a href="https://arxiv.org/abs/2301.03598">link</a>).</li>
</ul>
</li>
<li>
<p><strong>Newer GPUs:</strong></p>
<ul>
<li>NVIDIA’s Hopper generation of GPUs includes several new features which are relevant when writing matrix multiply kernels. Notably, these include an evolved version of asynchronous copy instructions using something called the “tensor memory accelerator” (TMA) (<a href="https://developer.nvidia.com/blog/nvidia-hopper-architecture-in-depth/">link</a>), as well as new extremely high-throughput tensor core instructions which run asynchronously, can load their inputs directly from shared memory, and work at a granularity of four warps at a time (<a href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-mma">PTX docs</a>). Even though these features are different than the ones we’ve covered in this course, we hope you feel that you’re now very well-prepared to figure out how to use them (we think you are!).</li>
</ul>
</li>
<li>
<p><strong>Alternative platforms:</strong></p>
<ul>
<li>Because deep learning is such an active space, there’s now a veritable zoo of different hardware accelerator platforms all designed to multiply matrices. Spanning various levels of readiness, performance, and public availability, these include: <a href="https://cloud.google.com/tpu">Google’s TPUs</a>, <a href="https://www.amd.com/en/products/accelerators/instinct/mi300/mi300x.html">AMD’s GPUs</a>, <a href="https://www.apple.com/newsroom/2024/05/apple-introduces-m4-chip/">Apple’s M-series chips</a>, <a href="https://www.intel.com/content/www/us/en/products/details/processors/ai-accelerators/gaudi-overview.html?cid=sem&amp;source=sa360&amp;campid=2024_ao_cbu_us_gmocoma_gmocrbu_awa_text-link_brand_exact_cd_HQ-ai-gaudi_3500268603_google_b2b_is_non-pbm_intel&amp;ad_group=AI_Brand-Gaudi_Gaudi_Exact&amp;intel_term=intel+gaudi&amp;sa360id=43700079829610445&amp;gad_source=1&amp;gclid=CjwKCAjwjsi4BhB5EiwAFAL0YMUtHoQrSRnN4bQqFSg3SvR9uBaTz8x4oA3q6AbsQUgtmOb8VOlOkxoCc9IQAvD_BwE&amp;gclsrc=aw.ds">Intel’s Gaudi</a>, <a href="https://www.graphcore.ai/bow-processors">Graphcore’s IPUs</a>, <a href="https://aws.amazon.com/machine-learning/trainium/">Amazon’s Trainium</a>, <a href="https://tenstorrent.com/">Tenstorrent’s various accelerators</a>, <a href="https://cerebras.ai/condor-galaxy">Cerebras’s Wafer-Scale Engine</a>, <a href="https://groq.com/groq-tensor-streaming-processor-architecture-is-radically-different/">Groq’s TSPs</a>, <a href="https://en.wikipedia.org/wiki/Tesla_Dojo">the chips in Tesla’s Dojo supercomputer</a>, <a href="https://www.etched.com/">Etched’s Sohu</a>, <a href="https://sambanova.ai/technology/sn40l-rdu-ai-chip">SambaNova’s RDU</a>, <a href="https://azure.microsoft.com/en-us/blog/azure-maia-for-the-era-of-ai-from-silicon-to-software-to-systems/">Microsoft’s MAIA</a>, and <a href="https://ai.meta.com/blog/next-generation-meta-training-inference-accelerator-AI-MTIA/">Meta’s MTIA</a> – and we’re sure we forgot some! You may get a chance to program some of these in the future – and although they’re not NVIDIA GPUs, many of the fundamental ideas we’ve covered should be relevant as you learn to program <strong>any</strong> of them!</li>
</ul>
</li>
</ul>
<p>In a few weeks, we’ll start discussing ideas for final projects. If any of the matrix-multiplication-related topics above sound interesting to you, keep them in mind when you’re thinking about what you might want to work on for your final project!</p>
<h2>Deliverables</h2>
<h3>Checkpoint (Due Monday, October 21, 2024)</h3>
<p>For the checkpoint for this lab, we ask that you:</p>
<ul>
<li>
<p><strong>Complete Part 1</strong>, so that you’re familiar with inline PTX syntax by the time we meet together for live lab.</p>
</li>
<li>
<p><strong>See how far you can get</strong> on <strong>Part 2</strong> and <strong>Part 3</strong>, and let us know anything you’re stuck on.</p>
<ul>
<li>We won’t require it, in case people get stuck, but <strong>if you can</strong>, please try to <strong>complete Part 2</strong> and <strong>get started on Part 3</strong> before live lab. If everyone gets started on Part 3 ahead of time, then we can spend as much time as possible during live lab discussing strategies for how to make our matrix multiply implementations run fast.</li>
</ul>
</li>
</ul>
<p>On the Gradescope assignment “Lab 6 Checkpoint,” (<a href="https://www.gradescope.com/courses/849967/assignments/5181469/">link</a>) submit your completed code for Part 1, and your answers to the prompts about how you’re doing on Part 2 and Part 3.</p>
<h3>Final Submission (Due Friday, October 25, 2024)</h3>
<p>On the Gradescope assignment “Lab 6 Final,” (<a href="https://www.gradescope.com/courses/849967/assignments/5181509/">link</a>), submit your completed code for <code>exercise_lop3.cu</code>, <code>exercise_mma.cu</code>, and <code>matmul_3.cu</code>, as well as a PDF write-up containing your answers to Questions 1 - 4.</p>
<hr />
<div class="footnote-definition" id="cutlass"><sup class="footnote-definition-label">1</sup>
<p>NVIDIA has developed an external library called <a href="https://github.com/NVIDIA/cutlass">“CUTLASS”</a> which provides a higher-level C++ interface for interacting with tensor cores. However, CUTLASS is built on top of many layers of complicated C++ template metaprogramming machinery, and in the course staff’s experience, accessing tensor cores directly via PTX provides better clarity about what’s actually going on. Libraries like CUTLASS can be convenient in practice, but they’re never necessary; anything you can do using CUTLASS, you can also do yourself using inline PTX.</p>
</div>
<div class="footnote-definition" id="lop3_opt"><sup class="footnote-definition-label">2</sup>
<p>In practice, thanks to compiler optimizations in the PTX-to-SASS translation step, if you write CUDA code which implements three-way bit-wise operations in terms of normal two-way bit-wise operators like <code>(a &amp; b) | c</code>, the compiler will sometimes end up generating fast <code>LOP3</code> instructions for you at the SASS level anyway. However, explicitly invoking the <code>lop3</code> instruction via inline PTX provides more control.</p>
</div>
<div class="footnote-definition" id="wmma"><sup class="footnote-definition-label">3</sup>
<p>In PTX there is also an API called <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/#warp-level-matrix-instructions-wmma-mma"><code>wmma</code></a>, which superficially appears to offer yet another way to use the machine’s tensor cores. However, inspecting the SASS generated for <code>wmma.mma</code> instructions reveals that, on our GPU, it ultimately compiles to the same <code>HMMA</code> instructions which are already exposed through the <code>mma</code> API we’re using for this lab. As far as we can tell, this alternate <code>wmma</code> API exists mostly for historical reasons.</p>
</div>
<div class="footnote-definition" id="illusion"><sup class="footnote-definition-label">4</sup>
<p>Tensor core instructions aren’t the only instructions on the GPU with warp-level semantics; there are also <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#warp-shuffle-functions">warp-level reductions and warp-level permutations</a>, among others. <a href="https://developer.nvidia.com/blog/using-cuda-warp-level-primitives/">This blog post</a> has some interesting commentary on such warp-level functions and their history.</p>
</div>
<div class="footnote-definition" id="cublas_fp32"><sup class="footnote-definition-label">5</sup>
<p>We make sure the cuBLAS kernels we’re calling won’t use tensor cores by explicitly requesting matrix multiplies in full FP32 precision as opposed to TF32 precision.</p>
</div>
</main><footer><p><a href="https://mit.edu">Massachusetts Institute of Technology</a> —
<a href="https://www.eecs.mit.edu">Department of Electrical Engineering and Computer Science</a></p>
</footer></body></html>